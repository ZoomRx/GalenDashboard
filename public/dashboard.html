<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Langfuse Usage Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/daterangepicker@3.1.0/daterangepicker.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/daterangepicker@3.1.0/daterangepicker.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Paste your existing CSS styles here */
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3f37c9;
            --accent-color: #4895ef;
            --text-color: #333;
            --light-bg: #f8f9fa;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            background-color: #f5f7fb;
            color: var(--text-color);
        }

        .dashboard-header {
            background-color: white;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-bottom: 1px solid var(--border-color);
        }

        .card {
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            border: none;
            transition: all 0.3s ease;
        }

        .card:hover {
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .card-header {
            background-color: white;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            padding: 15px 20px;
            border-top-left-radius: 10px !important;
            border-top-right-radius: 10px !important;
        }

        .metric-card .card-body {
            padding: 25px;
        }

        .metric-value {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .metric-label {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 0;
        }

        .filter-container {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }

        .tab-content {
            padding: 20px 0;
        }

        .tab-pane {
            animation: fadeIn 0.5s;
        }

        .nav-tabs .nav-link {
            color: #495057;
            font-weight: 500;
            border: none;
            padding: 10px 15px;
        }

        .nav-tabs .nav-link.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
            background-color: transparent;
        }

        .table {
            border-collapse: separate;
            border-spacing: 0;
            width: 100%; /* Ensure table takes full width */
        }

        .table th {
            background-color: #f8f9fa;
            font-weight: 600;
            white-space: nowrap; /* Prevent header text wrapping */
        }

        .table td, .table th {
            padding: 12px 15px;
            vertical-align: middle;
        }
        /* Add word-wrap for specific columns if needed */
        #userTable td:nth-child(1), /* User ID */
        #conversationTable td:nth-child(1), /* Conv ID */
        #sessionTable td:nth-child(1) /* Session ID */
         {
             word-break: break-all;
        }


        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .daterangepicker {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
        }

        #dateRangeFilter {
            background-color: white;
            border: 1px solid var(--border-color);
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 5px;
        }

        .badge-agent {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 12px;
            white-space: nowrap; /* Prevent badge text wrapping */
        }

        /* Agent badge colors (ensure these match your agents) */
        .agent-hcp_p { background-color: #8ac926; color: white; }
        .agent-scoping { background-color: #1982c4; color: white; }
        .agent-synapse { background-color: #6a4c93; color: white; }
        .agent-hashtag { background-color: #ff595e; color: white; }
        .agent-survey_coding { background-color: #ffca3a; color: black; }
        .agent-unknown { background-color: #adb5bd; color: white; } /* Default/unknown */


        .progress {
            height: 8px;
            border-radius: 4px;
        }

        .dropdown-item:hover {
            background-color: #f1f3f9;
        }

        .dropdown-item.active {
            background-color: var(--primary-color);
        }

        /* Add sorting indicators */
        th[data-field] { /* Only apply cursor to sortable headers */
             cursor: pointer;
        }
        .sorting-asc::after {
            content: ' ↑';
            color: var(--primary-color);
            font-size: 0.8em; /* Make arrow smaller */
        }

        .sorting-desc::after {
            content: ' ↓';
            color: var(--primary-color);
             font-size: 0.8em; /* Make arrow smaller */
        }

        /* Style pagination controls */
        .pagination-controls {
            margin-top: 1rem;
            padding: 0.5rem;
            background-color: #f8f9fa;
            border-radius: 0.25rem;
        }

        .pagination-info {
            color: #6c757d;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <template id="paginationTemplate">
        <div class="d-flex justify-content-between align-items-center mt-3 pagination-controls-inner">
            <div class="pagination-info">
                Showing <span class="showing-start">1</span>-<span class="showing-end">50</span> of <span class="total-items">0</span>
            </div>
            <div class="btn-group">
                <button class="btn btn-outline-primary btn-sm prev-page" disabled><i class="fas fa-chevron-left"></i> Previous</button>
                <button class="btn btn-outline-primary btn-sm next-page">Next <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </template>

    <div class="dashboard-header">
        <div class="container-fluid">
            <div class="row align-items-center">
                 <div class="col-md-6">
                    <h2 class="mb-0">Langfuse Usage Dashboard</h2>
                    <p class="text-muted mb-0">Monitor token usage, costs, and conversations across all agents</p>
                </div>
                <div class="col-md-6 text-end">
                    <div class="d-flex justify-content-end align-items-center">
                        <div class="me-3">
                            <label for="dateRangeFilter" class="visually-hidden">Date Range:</label>
                            <input type="text" id="dateRangeFilter" class="form-control form-control-sm" readonly>
                        </div>
                        <button id="fetchLatestButton" class="btn btn-success btn-sm ms-2">
                            <i class="fas fa-sync-alt"></i> Refresh Data
                        </button>
                    </div>
                     <div id="lastDataFetch" class="text-muted small mt-1 text-end" style="font-size: 0.75rem;"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid py-4">
        <div class="row mb-4">
            <div class="col-12">
                <div class="filter-container">
                    <div class="row g-3 align-items-end">
                        <div class="col-md-5">
                            <label for="agentFilter" class="form-label mb-1 small">Agent</label>
                            <select id="agentFilter" class="form-select form-select-sm">
                                <option value="all">All Agents</option>
                                </select>
                        </div>
                        <div class="col-md-5">
                             <label for="userFilter" class="form-label mb-1 small">User</label>
                            <select id="userFilter" class="form-select form-select-sm">
                                <option value="all">All Users</option>
                                </select>
                        </div>
                         <div class="col-md-2">
                             <button id="applyFiltersButton" class="btn btn-primary btn-sm w-100">Apply Filters</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-lg col-md-4 col-sm-6 mb-3">
                <div class="card metric-card h-100">
                    <div class="card-body text-center">
                        <h6 class="metric-label text-uppercase small">Total Tokens</h6>
                        <div id="totalTokensValue" class="metric-value">0</div>
                    </div>
                </div>
            </div>
            <div class="col-lg col-md-4 col-sm-6 mb-3">
                <div class="card metric-card h-100">
                    <div class="card-body text-center">
                        <h6 class="metric-label text-uppercase small">Total Cost (USD)</h6>
                        <div id="totalCostValue" class="metric-value">$0.00</div>
                    </div>
                </div>
            </div>
            <div class="col-lg col-md-4 col-sm-6 mb-3">
                <div class="card metric-card h-100">
                    <div class="card-body text-center">
                        <h6 class="metric-label text-uppercase small">Conversations</h6>
                        <div id="totalConversationsValue" class="metric-value">0</div>
                    </div>
                </div>
            </div>
            <div class="col-lg col-md-6 col-sm-6 mb-3">
                <div class="card metric-card h-100">
                    <div class="card-body text-center">
                        <h6 class="metric-label text-uppercase small">Sessions</h6>
                        <div id="totalSessionsValue" class="metric-value">0</div>
                    </div>
                </div>
            </div>
            <div class="col-lg col-md-6 col-sm-12 mb-3">
                <div class="card metric-card h-100">
                    <div class="card-body text-center">
                        <h6 class="metric-label text-uppercase small">Active Users</h6>
                        <div id="activeUsersValue" class="metric-value">0</div>
                    </div>
                </div>
            </div>
        </div>


        <div class="row mb-4">
            <div class="col-lg-8 mb-3">
                <div class="card h-100">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span>Daily Usage Trends</span>
                        <div class="btn-group btn-group-sm" role="group" id="dailyChartMetricToggle">
                            <button type="button" class="btn btn-outline-primary active" data-metric="tokens">Tokens</button>
                            <button type="button" class="btn btn-outline-primary" data-metric="cost">Cost</button>
                        </div>
                    </div>
                    <div class="card-body">
                         <div style="height: 300px;"><canvas id="dailyUsageChart"></canvas></div>
                    </div>
                </div>
            </div>
            <div class="col-lg-4 mb-3">
                <div class="card h-100">
                    <div class="card-header">Agent Conversation Distribution</div>
                    <div class="card-body">
                         <div style="height: 300px;"><canvas id="agentDistributionChart"></canvas></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header p-0">
                        <ul class="nav nav-tabs card-header-tabs" id="dataTabs" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="user-tab" data-bs-toggle="tab" data-bs-target="#user-data" type="button" role="tab">User Activity</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="conversation-tab" data-bs-toggle="tab" data-bs-target="#conversation-data" type="button" role="tab">Conversations (Traces)</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="session-tab" data-bs-toggle="tab" data-bs-target="#session-data" type="button" role="tab">Sessions</button>
                            </li>
                             <li class="nav-item" role="presentation">
                                <button class="nav-link" id="agent-tab" data-bs-toggle="tab" data-bs-target="#agent-data" type="button" role="tab">Agent Summary</button>
                            </li>
                             <li class="nav-item" role="presentation">
                                <button class="nav-link" id="model-tab" data-bs-toggle="tab" data-bs-target="#model-data" type="button" role="tab">Model Usage</button>
                            </li>
                        </ul>
                    </div>
                    <div class="card-body">
                        <div class="tab-content" id="dataTabsContent">
                            <div id="tableLoadingIndicator" class="text-center py-5" style="display: none;">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="mt-2">Loading data...</p>
                            </div>

                            <div class="tab-pane fade show active" id="user-data" role="tabpanel">
                                <div class="table-responsive">
                                    <table class="table table-hover table-sm small" id="userTable">
                                        <thead>
                                            <tr>
                                                <th data-field="userId">User ID</th>
                                                <th data-field="totalTraces">Total Conv.</th>
                                                <th data-field="agents" class="no-sort">Agents Used</th>
                                                <th data-field="firstSeen">First Seen</th>
                                                <th data-field="lastSeen">Last Seen</th>
                                                <th data-field="totalTokens">Total Tokens</th>
                                                <th data-field="totalCost">Total Cost ($)</th>
                                            </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <div id="user-pagination"></div>
                            </div>

                            <div class="tab-pane fade" id="conversation-data" role="tabpanel">
                                <div class="table-responsive">
                                    <table class="table table-hover table-sm small" id="conversationTable">
                                        <thead>
                                            <tr>
                                                <th data-field="id">Conv. ID</th>
                                                <th data-field="userId">User</th>
                                                <th data-field="agent">Agent</th>
                                                <th data-field="timestamp">Date</th>
                                                <th data-field="messageCount">Messages</th>
                                                <th data-field="totalTokens">Tokens</th>
                                                <th data-field="totalCost">Cost ($)</th>
                                            </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <div id="conversation-pagination"></div>
                            </div>

                            <div class="tab-pane fade" id="session-data" role="tabpanel">
                                <div class="table-responsive">
                                     <table class="table table-hover table-sm small" id="sessionTable">
                                        <thead>
                                            <tr>
                                                <th data-field="id">Session ID</th>
                                                <th data-field="userId">User</th>
                                                <th data-field="agent">Agent</th>
                                                <th data-field="createdAt">Start Time</th>
                                                <th data-field="durationSeconds">Duration</th>
                                                <th data-field="traceCount">Conv.</th>
                                                <th data-field="totalTokens">Tokens</th>
                                                <th data-field="totalCost">Cost ($)</th>
                                            </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                 <div id="session-pagination"></div>
                            </div>

                             <div class="tab-pane fade" id="agent-data" role="tabpanel">
                                <div class="table-responsive">
                                    <table class="table table-hover table-sm small" id="agentTable">
                                        <thead>
                                            <tr>
                                                <th data-field="agent">Agent</th>
                                                <th data-field="totalUsers">Total Users</th>
                                                <th data-field="countTraces">Total Conv.</th>
                                                <th data-field="avgMessagesPerConv">Avg Msgs/Conv</th>
                                                <th data-field="totalTokens">Total Tokens</th>
                                                <th data-field="totalCost">Total Cost ($)</th>
                                            </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                </div>

                            <div class="tab-pane fade" id="model-data" role="tabpanel">
                                <div class="table-responsive">
                                    <table class="table table-hover table-sm small" id="modelTable">
                                        <thead>
                                            <tr>
                                                <th data-field="model">Model Name</th>
                                                <th data-field="totalTokens">Total Tokens</th>
                                                <th data-field="totalCost">Total Cost ($)</th>
                                                </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <div id="model-pagination"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- Global Variables ---
        let dailyUsageChart;
        let agentDistributionChart;
        let allData = {}; // Store all fetched data
        let filteredData = {}; // Store data filtered by date/agent/user
        let lastDataFetchTime = null;
        const ITEMS_PER_PAGE = 50; // Pagination size

        // Global state for sorting and pagination per table
        const tableState = {
            user: { sortField: 'lastSeen', sortDirection: 'desc', currentPage: 1 },
            conversation: { sortField: 'timestamp', sortDirection: 'desc', currentPage: 1 },
            session: { sortField: 'createdAt', sortDirection: 'desc', currentPage: 1 },
            agent: { sortField: 'totalCost', sortDirection: 'desc', currentPage: 1 }, // Example sort for agent table
            model: { sortField: 'totalCost', sortDirection: 'desc', currentPage: 1 }, // Example sort for model table
        };


        // --- Utility Functions ---

        // Format numbers and currency
        function formatNumber(num) {
            return (num || 0).toLocaleString();
        }
        function formatCost(num) {
            return '$' + (num || 0).toFixed(4); // Show more precision for cost
        }
        function formatDuration(seconds) {
            if (seconds === null || seconds === undefined || seconds < 0) return '-';
            if (seconds < 60) return `${Math.round(seconds)}s`;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.round(seconds % 60);
            if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return `${hours}h ${remainingMinutes}m`;
        }
        // Format dates using moment for better localization/consistency if needed
        function formatDate(dateString, format = 'L') { // 'L' is locale default short date
             if (!dateString) return '-';
             const date = moment.utc(dateString); // Assume UTC from Python
             return date.isValid() ? date.local().format(format) : '-'; // Display in local time
        }
         function formatDateTime(dateString, format = 'L LT') { // 'L LT' is locale date + time
             if (!dateString) return '-';
             const date = moment.utc(dateString); // Assume UTC from Python
             return date.isValid() ? date.local().format(format) : '-'; // Display in local time
        }

        // Get badge class for agent (lowercase and replace spaces/special chars)
        function getAgentBadgeClass(agentName) {
            if (!agentName) return 'agent-unknown';
            const className = agentName.toLowerCase().replace(/[^a-z0-9]+/g, '_');
            // Check if a specific style exists, otherwise use a default
            // This requires defining CSS like .agent-hcp_p, .agent-survey_coding etc.
             // Example: If agent name is "HCP P", class becomes "agent-hcp_p"
            // Example: If agent name is "Survey_Coding", class becomes "agent-survey_coding"
            // We need to ensure CSS rules match these generated classes.
            // Let's stick to the predefined ones for now and add a check.
            const knownAgents = ['hcp_p', 'scoping', 'synapse', 'hashtag', 'survey_coding'];
            if (knownAgents.includes(className)) {
                return `agent-${className}`;
            }
            // Fallback for potentially dynamic agent names - create a consistent hash?
            // Or just use a default 'agent-other' class
            return 'agent-unknown'; // Default if no specific style found
        }

        // Fetch JSON data helper
        async function fetchJson(url) {
            try {
                const response = await fetch(`${url}?t=${new Date().getTime()}`); // Cache bust
                if (!response.ok) {
                    console.error(`HTTP error fetching ${url}: ${response.status} ${response.statusText}`);
                    // Try to read error message from response body if available
                     let errorBody = '';
                    try { errorBody = await response.text(); } catch (e) { /* ignore */}
                    console.error("Error response body:", errorBody);
                    throw new Error(`HTTP error ${response.status}`);
                }
                 // Check content type before parsing
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                     return await response.json();
                } else {
                     console.error(`Received non-JSON response from ${url}. Content-Type: ${contentType}`);
                    // Handle non-JSON response appropriately, e.g., return empty or throw error
                    // For robustness, let's return an empty structure based on expected type
                    // This is a basic check; might need refinement based on file names
                     return url.includes('daily') || url.includes('agent') || url.includes('user') || url.includes('conversation') || url.includes('model') || url.includes('all') ? [] : {};
                 }
            } catch (error) {
                console.error(`Error fetching or parsing ${url}:`, error);
                // Return default empty structure based on expected type
                return url.includes('daily') || url.includes('agent') || url.includes('user') || url.includes('conversation') || url.includes('model') || url.includes('all') ? [] : {};
            }
        }

         // Log frontend events (placeholder)
        function logFrontendEvent(message) {
            console.log("FE Log:", message);
            // Optional: Send to backend endpoint if needed
            // fetch('/api/log', { /* ... */ });
        }

        // Show/Hide loading indicator
        function showLoading(tabId = null) {
             const indicator = document.getElementById('tableLoadingIndicator');
             if (indicator) indicator.style.display = 'block';
             // Optionally hide the specific table body while loading
             if (tabId) {
                const tableBody = document.querySelector(`#${tabId} tbody`);
                 if (tableBody) tableBody.style.display = 'none';
             }
        }
        function hideLoading(tabId = null) {
             const indicator = document.getElementById('tableLoadingIndicator');
             if (indicator) indicator.style.display = 'none';
             // Show the table body again
             if (tabId) {
                 const tableBody = document.querySelector(`#${tabId} tbody`);
                 if (tableBody) tableBody.style.display = ''; // Reset display
             }
        }

        // --- Data Loading and Processing ---

        // Load all necessary data files
        async function loadAllData() {
            showLoading();
             logFrontendEvent("Initiating data load...");
            const dataFiles = [
                'all_daily_metrics.json', 'all_traces.json', 'all_sessions.json',
                'user_metrics.json', 'agent_comparison.json', // Core summary files
                'model_token_usage.json' // Added model usage summary
                // 'all_observations.json' - Load only if needed for drill-down, can be large
            ];
            const promises = dataFiles.map(file => fetchJson(`/dashboard_data/${file}`));

            try {
                const results = await Promise.all(promises);
                allData = {
                    dailyMetrics: results[0] || [],
                    traces: results[1] || [],
                    sessions: results[2] || [],
                    userMetrics: results[3] || [],
                    agentComparison: results[4] || [],
                    modelUsage: results[5] || [], // Store model usage
                    // observations: results[6] || [] // If loading observations
                };
                logFrontendEvent(`Data loaded: ${allData.traces?.length} traces, ${allData.sessions?.length} sessions, ${allData.dailyMetrics?.length} daily records.`);

                 // Convert timestamp strings back to Date objects for easier filtering/sorting
                const parseDates = (items, dateFields) => {
                    if (!Array.isArray(items)) return;
                    items.forEach(item => {
                         dateFields.forEach(field => {
                            if (item[field]) {
                                item[field] = moment.utc(item[field]).toDate(); // Use moment to parse ISO strings
                            }
                         });
                    });
                };
                parseDates(allData.traces, ['timestamp', 'startTime', 'endTime']);
                parseDates(allData.sessions, ['createdAt', 'startTime', 'endTime']);
                parseDates(allData.userMetrics, ['firstSeen', 'lastSeen']);
                // Daily metrics 'date' field is just YYYY-MM-DD, keep as string or parse if needed


                populateFilterOptions(); // Populate filters based on loaded data
                applyFiltersAndRefresh(); // Apply initial filters (date range, all agents/users)
                updateLastDataFetch(true); // Set last data fetch time from successful load

            } catch (error) {
                console.error('Error loading dashboard data:', error);
                alert('Failed to load dashboard data. Please check the console for details and ensure the data files exist.');
                updateLastDataFetch(false); // Indicate fetch failure
            } finally {
                 hideLoading();
            }
        }

        // Populate Agent and User filter dropdowns
        function populateFilterOptions() {
            const agentSelect = document.getElementById('agentFilter');
            const userSelect = document.getElementById('userFilter');

            // Agents from agentComparison or directly from traces/sessions/metrics
            const agents = [...new Set(allData.dailyMetrics.map(m => m.agent))].sort();
             // Clear existing options except 'All'
            agentSelect.innerHTML = '<option value="all">All Agents</option>';
            agents.forEach(agent => {
                const option = document.createElement('option');
                option.value = agent;
                option.textContent = agent; // Consider a mapping for user-friendly names if needed
                agentSelect.appendChild(option);
            });

            // Users from userMetrics
            const users = [...new Set(allData.userMetrics.map(u => u.userId))].sort();
             // Clear existing options except 'All'
            userSelect.innerHTML = '<option value="all">All Users</option>';
            users.forEach(userId => {
                const option = document.createElement('option');
                option.value = userId;
                option.textContent = userId;
                userSelect.appendChild(option);
            });
             logFrontendEvent(`Populated filters: ${agents.length} agents, ${users.length} users.`);
        }


        // Filter data based on date range, agent, user
        function applyFiltersAndRefresh() {
             logFrontendEvent("Applying filters and refreshing dashboard...");
            const agentFilter = document.getElementById('agentFilter').value;
            const userFilter = document.getElementById('userFilter').value;
            const dateRange = $('#dateRangeFilter').data('daterangepicker');
            const startDate = dateRange.startDate.toDate(); // Get JS Date object
            const endDate = dateRange.endDate.endOf('day').toDate(); // Get JS Date object (end of day)

             filteredData = {}; // Reset filtered data

            // Filter Daily Metrics (match date string)
             const startDateStr = dateRange.startDate.format('YYYY-MM-DD');
             const endDateStr = dateRange.endDate.format('YYYY-MM-DD');
             filteredData.dailyMetrics = allData.dailyMetrics?.filter(m =>
                 m.date >= startDateStr && m.date <= endDateStr &&
                 (agentFilter === 'all' || m.agent === agentFilter)
             ) ?? [];

             // Filter Traces (use Date objects for comparison)
             filteredData.traces = allData.traces?.filter(t =>
                 t.timestamp >= startDate && t.timestamp <= endDate &&
                 (agentFilter === 'all' || t.agent === agentFilter) &&
                 (userFilter === 'all' || t.userId === userFilter)
            ) ?? [];

             // Filter Sessions (use Date objects for comparison - createdAt or startTime)
             filteredData.sessions = allData.sessions?.filter(s =>
                 s.createdAt >= startDate && s.createdAt <= endDate && // Filter by creation time
                 (agentFilter === 'all' || s.agent === agentFilter) &&
                 (userFilter === 'all' || s.userId === userFilter)
             ) ?? [];

             // Filter User Metrics (based on lastSeen within range, and agent/user selection)
             // Note: User metrics are pre-aggregated, filtering might need different logic
             // Let's filter users who were active (lastSeen) in the period
             filteredData.userMetrics = allData.userMetrics?.filter(u =>
                 (u.lastSeen >= startDate && u.lastSeen <= endDate) &&
                 (userFilter === 'all' || u.userId === userFilter) &&
                 (agentFilter === 'all' || u.agents.includes(agentFilter)) // Check if user used the selected agent
             ) ?? [];

             // Filter Model Usage (aggregate from filtered traces/observations if needed, or use pre-aggregated)
             // For now, use the pre-aggregated data and filter later if necessary or show all models used in period.
             // Let's recalculate model usage based on *filtered* traces/observations if available
             // For simplicity, we'll just use the pre-aggregated `allData.modelUsage` for now.
             // A more accurate approach would re-aggregate from filtered observations.
              filteredData.modelUsage = allData.modelUsage ?? []; // Using pre-aggregated for now

             logFrontendEvent(`Filtering complete: ${filteredData.traces?.length} traces, ${filteredData.sessions?.length} sessions remain.`);

            updateDashboard(); // Refresh UI components
        }

        // --- UI Update Functions ---

        function updateDashboard() {
             logFrontendEvent("Updating dashboard UI...");
            updateSummaryMetrics();
            updateCharts();
            updateActiveTable(); // Update the currently visible table
        }

        function updateSummaryMetrics() {
            let totalTokens = 0;
            let totalCost = 0.0;
            let agentSet = new Set(); // Agents active in the filtered period

            // Sum from filtered daily metrics
             filteredData.dailyMetrics?.forEach(day => {
                totalTokens += day.totalTokens || 0;
                totalCost += day.totalCost || 0.0;
                agentSet.add(day.agent);
             });

            // Alternative: Sum from filtered traces if daily metrics are missing/incomplete
            // if (totalTokens === 0 && totalCost === 0) {
            //    filteredData.traces?.forEach(trace => {
            //       totalTokens += trace.totalTokens || 0;
            //       totalCost += trace.totalCost || 0.0;
            //       agentSet.add(trace.agent);
            //    });
            // }


            const totalConversations = filteredData.traces?.length ?? 0;
            const totalSessions = filteredData.sessions?.length ?? 0;
            // Count unique users from the filtered traces
            const activeUsers = new Set(filteredData.traces?.map(t => t.userId).filter(Boolean)).size;


            document.getElementById('totalTokensValue').textContent = formatNumber(totalTokens);
            document.getElementById('totalCostValue').textContent = formatCost(totalCost); // Use more precision
            document.getElementById('totalConversationsValue').textContent = formatNumber(totalConversations);
            document.getElementById('totalSessionsValue').textContent = formatNumber(totalSessions);
            document.getElementById('activeUsersValue').textContent = formatNumber(activeUsers);
        }

        function updateCharts() {
            updateDailyUsageChart();
            updateAgentDistributionChart();
        }

        // --- Chart Initialization and Updates ---

        function initializeCharts() {
            // Daily usage chart
            const dailyCtx = document.getElementById('dailyUsageChart').getContext('2d');
            dailyUsageChart = new Chart(dailyCtx, {
                type: 'line',
                data: { labels: [], datasets: [] }, // Initial empty data
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: { // Custom tooltip formatting
                                 label: function(context) {
                                     let label = context.dataset.label || '';
                                     if (label) { label += ': '; }
                                     const value = context.parsed.y;
                                     const metricType = document.querySelector('#dailyChartMetricToggle .active')?.dataset.metric || 'tokens';
                                     if (value !== null) {
                                          label += metricType === 'cost' ? formatCost(value) : formatNumber(value);
                                     }
                                     return label;
                                 }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: {
                            beginAtZero: true,
                            ticks: { // Format Y-axis ticks
                                 callback: function(value) {
                                     const metricType = document.querySelector('#dailyChartMetricToggle .active')?.dataset.metric || 'tokens';
                                      return metricType === 'cost' ? formatCost(value) : formatNumber(value);
                                 }
                             },
                            title: { display: true, text: 'Usage' } // Dynamic title set in update
                        }
                    }
                }
            });

            // Agent distribution chart (using trace counts)
            const agentCtx = document.getElementById('agentDistributionChart').getContext('2d');
             // Define consistent colors mapped to agent names if possible
             const agentColors = {
                'HCP_P': '#8ac926',
                'SCOPING': '#1982c4',
                'SYNAPSE': '#6a4c93',
                'HASHTAG': '#ff595e',
                'SURVEY_CODING': '#ffca3a',
                // Add more agents and colors as needed
                'default': '#adb5bd' // Fallback color
             };
            agentDistributionChart = new Chart(agentCtx, {
                type: 'doughnut',
                 data: {
                     labels: [],
                     datasets: [{
                         data: [],
                         backgroundColor: [], // Set dynamically
                         borderWidth: 1,
                         borderColor: '#fff' // Add white border for separation
                     }]
                 },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                     plugins: {
                        legend: {
                            position: 'right',
                            labels: { boxWidth: 12 } // Smaller legend boxes
                        },
                        tooltip: {
                             callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) { label += ': '; }
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0%';
                                    if (value !== null) {
                                        label += formatNumber(value) + ` (${percentage})`;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    cutout: '65%'
                }
            });
        }

        function updateDailyUsageChart() {
            const metricType = document.querySelector('#dailyChartMetricToggle .active')?.dataset.metric || 'tokens';
            const sourceData = filteredData.dailyMetrics ?? [];

            // Aggregate data per date, summing across agents if 'all' selected, or showing individual lines
             const aggregated = {}; // { date: { agent1: value, agent2: value, ... } }
             const agents = new Set();
             sourceData.forEach(item => {
                 const date = item.date;
                 const agent = item.agent;
                 agents.add(agent);
                 if (!aggregated[date]) aggregated[date] = { date: date };
                 const value = metricType === 'cost' ? item.totalCost : item.totalTokens;
                 aggregated[date][agent] = (aggregated[date][agent] || 0) + value;
             });

             const sortedDates = Object.keys(aggregated).sort();
             const labels = sortedDates.map(date => formatDate(date, 'MMM D')); // Format date labels

             const agentColors = { /* Keep your agentColors map */
                 'HCP_P': '#8ac926', 'SCOPING': '#1982c4', 'SYNAPSE': '#6a4c93',
                 'HASHTAG': '#ff595e', 'SURVEY_CODING': '#ffca3a', 'default': '#adb5bd'
             };
              const datasets = Array.from(agents).sort().map(agent => {
                 const color = agentColors[agent.toUpperCase().replace(/[^A-Z0-9_]+/g, '')] || agentColors['default'];
                 return {
                     label: agent,
                     data: sortedDates.map(date => aggregated[date][agent] || 0),
                     borderColor: color,
                     backgroundColor: color + '33', // Add alpha for fill
                     borderWidth: 1.5,
                     tension: 0.1,
                     pointRadius: 1,
                     pointHoverRadius: 4,
                     fill: true
                 };
             });

            dailyUsageChart.data.labels = labels;
            dailyUsageChart.data.datasets = datasets;
            dailyUsageChart.options.scales.y.title.text = metricType === 'cost' ? 'Cost (USD)' : 'Tokens';
            dailyUsageChart.update();
        }

        function updateAgentDistributionChart() {
            // Use filtered traces to count conversations per agent
            const agentCounts = {};
            filteredData.traces?.forEach(trace => {
                const agent = trace.agent || 'Unknown';
                agentCounts[agent] = (agentCounts[agent] || 0) + 1;
            });

            const sortedAgents = Object.entries(agentCounts).sort(([, countA], [, countB]) => countB - countA);
            const labels = sortedAgents.map(([agent]) => agent);
            const data = sortedAgents.map(([, count]) => count);

             const agentColors = { /* Keep your agentColors map */
                 'HCP_P': '#8ac926', 'SCOPING': '#1982c4', 'SYNAPSE': '#6a4c93',
                 'HASHTAG': '#ff595e', 'SURVEY_CODING': '#ffca3a', 'default': '#adb5bd'
             };
             const backgroundColors = labels.map(label => agentColors[label.toUpperCase().replace(/[^A-Z0-9_]+/g, '')] || agentColors['default']);


            agentDistributionChart.data.labels = labels;
            agentDistributionChart.data.datasets[0].data = data;
            agentDistributionChart.data.datasets[0].backgroundColor = backgroundColors;
            agentDistributionChart.update();
        }

        // --- Table Rendering ---

        function renderTable(tableId, data, columns, stateKey) {
             const tableBody = document.querySelector(`#${tableId} tbody`);
             const paginationContainer = document.getElementById(`${stateKey}-pagination`);
             if (!tableBody || !paginationContainer) {
                 console.error(`Table or pagination container not found for ${tableId}`);
                 return;
             }
             showLoading(tableId); // Show loading specific to this table

             tableBody.innerHTML = ''; // Clear existing rows
             paginationContainer.innerHTML = ''; // Clear existing pagination

             if (!data || data.length === 0) {
                 tableBody.innerHTML = `<tr><td colspan="${columns.length}" class="text-center text-muted py-4">No data available for the selected filters.</td></tr>`;
                 hideLoading(tableId);
                 return;
             }

             // Apply Sorting
            let sortedData = [...data]; // Create a copy
            const { sortField, sortDirection } = tableState[stateKey];
            if (sortField) {
                 sortedData = sortData(sortedData, sortField, sortDirection);
             }

             // Apply Pagination
            const { currentPage } = tableState[stateKey];
            const totalItems = sortedData.length;
            const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
             const start = (currentPage - 1) * ITEMS_PER_PAGE;
             const paginatedData = sortedData.slice(start, start + ITEMS_PER_PAGE);

             // Render Rows
             paginatedData.forEach(item => {
                 const row = document.createElement('tr');
                 columns.forEach(column => {
                     const cell = document.createElement('td');
                     cell.innerHTML = column.render(item); // Use render function for content
                     // Add CSS classes if defined
                      if (column.cellClass) {
                          // Can be a string or a function
                          const classes = typeof column.cellClass === 'function'
                              ? column.cellClass(item)
                              : column.cellClass;
                          if (classes) cell.className = classes;
                      }
                     row.appendChild(cell);
                 });
                 tableBody.appendChild(row);
             });

             // Render Pagination Controls
             setupPagination(paginationContainer.id, stateKey, totalItems, ITEMS_PER_PAGE, (newPage) => {
                 tableState[stateKey].currentPage = newPage;
                 renderTable(tableId, data, columns, stateKey); // Re-render the table for the new page
             });

              hideLoading(tableId); // Hide loading indicator
         }

         // Define columns for each table
         const userColumns = [
             { header: 'User ID', field: 'userId', render: item => item.userId || 'Unknown', cellClass: 'text-break' },
             { header: 'Total Conv.', field: 'totalTraces', render: item => formatNumber(item.totalTraces), cellClass: 'text-end' },
             { header: 'Agents Used', field: 'agents', sortable: false, render: item => (item.agents || []).map(agent => `<span class="badge badge-agent ${getAgentBadgeClass(agent)} me-1">${agent}</span>`).join(' ') },
             { header: 'First Seen', field: 'firstSeen', render: item => formatDate(item.firstSeen) },
             { header: 'Last Seen', field: 'lastSeen', render: item => formatDate(item.lastSeen) },
             { header: 'Total Tokens', field: 'totalTokens', render: item => formatNumber(item.totalTokens), cellClass: 'text-end' },
             { header: 'Total Cost ($)', field: 'totalCost', render: item => formatCost(item.totalCost), cellClass: 'text-end' },
         ];
         const conversationColumns = [
             { header: 'Conv. ID', field: 'id', render: item => item.id?.substring(0, 8) + '...' || '-', cellClass: 'text-break' }, // Shorten ID
             { header: 'User', field: 'userId', render: item => item.userId || 'Unknown' },
             { header: 'Agent', field: 'agent', render: item => `<span class="badge badge-agent ${getAgentBadgeClass(item.agent)}">${item.agent || 'Unknown'}</span>` },
             { header: 'Date', field: 'timestamp', render: item => formatDateTime(item.timestamp) },
             { header: 'Messages', field: 'messageCount', render: item => formatNumber(item.messageCount), cellClass: 'text-end' },
             { header: 'Tokens', field: 'totalTokens', render: item => formatNumber(item.totalTokens), cellClass: 'text-end' },
             { header: 'Cost ($)', field: 'totalCost', render: item => formatCost(item.totalCost), cellClass: 'text-end' },
         ];
         const sessionColumns = [
             { header: 'Session ID', field: 'id', render: item => item.id?.substring(0, 8) + '...' || '-', cellClass: 'text-break' },
             { header: 'User', field: 'userId', render: item => item.userId || 'Unknown' },
             { header: 'Agent', field: 'agent', render: item => `<span class="badge badge-agent ${getAgentBadgeClass(item.agent)}">${item.agent || 'Unknown'}</span>` },
             { header: 'Start Time', field: 'createdAt', render: item => formatDateTime(item.createdAt) },
             { header: 'Duration', field: 'durationSeconds', render: item => formatDuration(item.durationSeconds), cellClass: 'text-end' },
             { header: 'Conv.', field: 'traceCount', render: item => formatNumber(item.traceCount), cellClass: 'text-end' },
             { header: 'Tokens', field: 'totalTokens', render: item => formatNumber(item.totalTokens), cellClass: 'text-end' },
             { header: 'Cost ($)', field: 'totalCost', render: item => formatCost(item.totalCost), cellClass: 'text-end' },
         ];
          const agentColumns = [
             { header: 'Agent', field: 'agent', render: item => `<span class="badge badge-agent ${getAgentBadgeClass(item.agent)} me-1">${item.agent}</span>` },
             { header: 'Total Users', field: 'totalUsers', render: item => formatNumber(item.totalUsers), cellClass: 'text-end' },
             { header: 'Total Conv.', field: 'countTraces', render: item => formatNumber(item.countTraces), cellClass: 'text-end' },
             { header: 'Avg Msgs/Conv', field: 'avgMessagesPerConv', render: item => item.avgMessagesPerConv?.toFixed(1) ?? '-', cellClass: 'text-end' },
             { header: 'Total Tokens', field: 'totalTokens', render: item => formatNumber(item.totalTokens), cellClass: 'text-end' },
             { header: 'Total Cost ($)', field: 'totalCost', render: item => formatCost(item.totalCost), cellClass: 'text-end' },
         ];
         const modelColumns = [
             { header: 'Model Name', field: 'model', render: item => item.model || 'Unknown', cellClass: 'text-break' },
             { header: 'Total Tokens', field: 'totalTokens', render: item => formatNumber(item.totalTokens), cellClass: 'text-end' },
             { header: 'Total Cost ($)', field: 'totalCost', render: item => formatCost(item.totalCost), cellClass: 'text-end' },
         ];


         // Update tables based on the currently active tab
         function updateActiveTable() {
             const activeTabButton = document.querySelector('#dataTabs .nav-link.active');
             if (!activeTabButton) return;
             const targetPaneId = activeTabButton.getAttribute('data-bs-target'); // e.g., #user-data

             switch (targetPaneId) {
                 case '#user-data':
                     renderTable('userTable', filteredData.userMetrics, userColumns, 'user');
                     break;
                 case '#conversation-data':
                     renderTable('conversationTable', filteredData.traces, conversationColumns, 'conversation');
                     break;
                 case '#session-data':
                     renderTable('sessionTable', filteredData.sessions, sessionColumns, 'session');
                     break;
                 case '#agent-data':
                     // Prepare agent summary data before rendering
                      const agentSummaryData = prepareAgentSummaryData();
                     renderTable('agentTable', agentSummaryData, agentColumns, 'agent');
                     break;
                 case '#model-data':
                      renderTable('modelTable', filteredData.modelUsage, modelColumns, 'model');
                     break;
             }
         }

          // Helper function to prepare data for the Agent Summary table
          function prepareAgentSummaryData() {
                if (!allData || !allData.agentComparison) return [];

                 const agentSummary = {};

                 // Initialize with basic info from agentComparison (trace counts)
                (allData.agentComparison ?? []).forEach(comp => {
                    agentSummary[comp.agent] = {
                         agent: comp.agent,
                         countTraces: comp.countTraces || 0,
                         totalUsers: 0,
                         avgMessagesPerConv: 0,
                         totalTokens: 0,
                         totalCost: 0.0,
                         _traceIds: new Set(), // Temp storage for avg calc
                         _userIds: new Set() // Temp storage for user count
                     };
                });

                 // Aggregate from daily metrics (more reliable for cost/tokens)
                 // Use *filtered* daily metrics to reflect date range
                (filteredData.dailyMetrics ?? []).forEach(metric => {
                     if (agentSummary[metric.agent]) {
                         agentSummary[metric.agent].totalTokens += metric.totalTokens || 0;
                         agentSummary[metric.agent].totalCost += metric.totalCost || 0.0;
                     }
                 });

                 // Aggregate users and trace details from *filtered* traces
                 let totalMessages = 0;
                 let totalTraceCountForAvg = 0;
                 (filteredData.traces ?? []).forEach(trace => {
                     if (agentSummary[trace.agent]) {
                         agentSummary[trace.agent]._userIds.add(trace.userId);
                         agentSummary[trace.agent]._traceIds.add(trace.id);
                         // Sum messages only from traces belonging to this agent
                         totalMessages += trace.messageCount || 0;
                         totalTraceCountForAvg++; // Count traces with potential messages
                     }
                 });

                 // Finalize calculations for each agent
                 Object.values(agentSummary).forEach(summary => {
                     summary.totalUsers = summary._userIds.size;
                     const agentTraceCount = summary._traceIds.size; // Use actual count of filtered traces for the agent
                     const agentTotalMessages = (filteredData.traces ?? [])
                        .filter(t => t.agent === summary.agent)
                        .reduce((sum, t) => sum + (t.messageCount || 0), 0);

                     summary.avgMessagesPerConv = agentTraceCount > 0 ? (agentTotalMessages / agentTraceCount) : 0;

                     // Update countTraces to reflect filtered count if desired, or keep total from agentComparison
                     // Let's keep the total from agentComparison for now, showing overall agent popularity
                     // summary.countTraces = agentTraceCount; // Uncomment to show filtered trace count

                     delete summary._traceIds; // Clean up temp storage
                     delete summary._userIds; // Clean up temp storage
                 });


                 return Object.values(agentSummary);
            }


        // --- Sorting and Pagination Utilities ---

        function sortData(data, field, direction = 'asc') {
            // Find the column definition to check for custom sort function
            // This requires knowing which column set we are sorting (user, conv, etc.)
            // For now, implement generic sort
            return [...data].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];

                // Handle different data types
                 if (aVal instanceof Date && bVal instanceof Date) {
                     aVal = aVal.getTime();
                     bVal = bVal.getTime();
                 } else if (typeof aVal === 'string' && typeof bVal === 'string') {
                     aVal = aVal.toLowerCase();
                     bVal = bVal.toLowerCase();
                 } else if (Array.isArray(aVal) && Array.isArray(bVal)) {
                    // Basic array sort (e.g., agents) - sort by length or first element
                    aVal = aVal.length;
                    bVal = bVal.length;
                 }
                 // Handle null or undefined values (treat them as lowest)
                 const aIsNull = aVal === null || aVal === undefined;
                 const bIsNull = bVal === null || bVal === undefined;
                 if (aIsNull && bIsNull) return 0;
                 if (aIsNull) return direction === 'asc' ? -1 : 1;
                 if (bIsNull) return direction === 'asc' ? 1 : -1;


                if (aVal < bVal) return direction === 'asc' ? -1 : 1;
                if (aVal > bVal) return direction === 'asc' ? 1 : -1;
                return 0;
            });
        }

        // Setup table sorting listeners
        function setupTableSorting(tableId, stateKey, columns) {
            const table = document.getElementById(tableId);
            if (!table) return;
            const headers = table.querySelectorAll('thead th[data-field]'); // Only target headers with data-field

            headers.forEach(header => {
                 // Check if column is explicitly marked as non-sortable
                 const columnDef = columns.find(c => c.field === header.dataset.field);
                 if (columnDef && columnDef.sortable === false) {
                    header.style.cursor = 'default'; // Remove pointer cursor
                    return; // Skip adding listener
                 }


                header.style.cursor = 'pointer'; // Add pointer cursor
                header.addEventListener('click', () => {
                    const field = header.dataset.field;
                    let newDir = 'asc';

                    // Clear existing sort indicators from all headers in this table
                    table.querySelectorAll('thead th[data-field]').forEach(h => h.classList.remove('sorting-asc', 'sorting-desc'));

                    // Determine new sort direction
                    if (tableState[stateKey].sortField === field) {
                        newDir = tableState[stateKey].sortDirection === 'asc' ? 'desc' : 'asc';
                    }

                    // Update state
                    tableState[stateKey].sortField = field;
                    tableState[stateKey].sortDirection = newDir;
                    tableState[stateKey].currentPage = 1; // Reset to first page

                    // Add new sort indicator
                    header.classList.add(newDir === 'asc' ? 'sorting-asc' : 'sorting-desc');

                     logFrontendEvent(`Sorting table ${tableId} by ${field} (${newDir})`);
                    // Re-render the active table with new sorting
                    updateActiveTable();
                });
                 // Add initial sort indicator based on default state
                 if (tableState[stateKey].sortField === header.dataset.field) {
                     header.classList.add(tableState[stateKey].sortDirection === 'asc' ? 'sorting-asc' : 'sorting-desc');
                 }
            });
        }

        // Setup pagination controls
        function setupPagination(containerId, stateKey, totalItems, itemsPerPage, onPageChange) {
             const container = document.getElementById(containerId);
             if (!container) return;
             container.innerHTML = ''; // Clear previous controls

             if (totalItems <= itemsPerPage) return; // No pagination needed if fits on one page

            const template = document.getElementById('paginationTemplate');
            if (!template) return; // Ensure template exists
            const paginationControls = template.content.cloneNode(true);


            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const currentPage = tableState[stateKey].currentPage;
            const startItem = (currentPage - 1) * itemsPerPage + 1;
            const endItem = Math.min(startItem + itemsPerPage - 1, totalItems);

            // Update showing info
            paginationControls.querySelector('.showing-start').textContent = formatNumber(startItem);
            paginationControls.querySelector('.showing-end').textContent = formatNumber(endItem);
            paginationControls.querySelector('.total-items').textContent = formatNumber(totalItems);

            // Setup buttons
            const prevBtn = paginationControls.querySelector('.prev-page');
            const nextBtn = paginationControls.querySelector('.next-page');

            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = currentPage === totalPages;

            prevBtn.addEventListener('click', () => onPageChange(currentPage - 1));
            nextBtn.addEventListener('click', () => onPageChange(currentPage + 1));

            container.appendChild(paginationControls);
        }


        // --- Event Listeners ---

        // Initialize date range picker
        function initializeDateRangePicker() {
            $('#dateRangeFilter').daterangepicker({
                startDate: moment().subtract(30, 'days'),
                endDate: moment(),
                opens: 'left',
                 locale: { format: 'YYYY-MM-DD' }, // Match Python date format if needed
                ranges: {
                   'Today': [moment(), moment()],
                   'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
                   'Last 7 Days': [moment().subtract(6, 'days'), moment()],
                   'Last 30 Days': [moment().subtract(29, 'days'), moment()],
                   'This Month': [moment().startOf('month'), moment().endOf('month')],
                   'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')]
                }
            }, function(start, end, label) {
                // Apply filters when date range changes
                 logFrontendEvent(`Date range changed: ${start.format('YYYY-MM-DD')} to ${end.format('YYYY-MM-DD')}`);
                 applyFiltersAndRefresh();
            });
        }

        // Update last data fetch timestamp display
        function updateLastDataFetch(success = true) {
             const display = document.getElementById('lastDataFetch');
             if (!display) return;

            if (success) {
                lastDataFetchTime = new Date();
                localStorage.setItem('dashboardLastDataFetch', lastDataFetchTime.toISOString());
            } else {
                 // If fetch failed, try to load last known good time
                 const storedTime = localStorage.getItem('dashboardLastDataFetch');
                 if (storedTime) {
                     lastDataFetchTime = new Date(storedTime);
                 } else {
                     lastDataFetchTime = null; // No known good fetch time
                 }
            }

            if (lastDataFetchTime) {
                 display.textContent = `Data last refreshed: ${moment(lastDataFetchTime).fromNow()}`;
                 display.title = lastDataFetchTime.toLocaleString(); // Show full time on hover
                 display.classList.remove('text-danger');
            } else {
                 display.textContent = 'Data refresh status unknown.';
                 display.classList.add('text-danger');
            }
        }

         // Initial setup on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
             initializeCharts();
             initializeDateRangePicker();
             updateLastDataFetch(false); // Initialize display, assuming no fetch yet

             // Load initial data
             loadAllData(); // This now handles filtering and initial UI update

             // Filter apply button listener
             document.getElementById('applyFiltersButton').addEventListener('click', applyFiltersAndRefresh);

              // Manual Refresh button listener
             document.getElementById('fetchLatestButton').addEventListener('click', function() {
                const btn = this;
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Refreshing...';
                logFrontendEvent('Manual data refresh requested...');

                // Simple approach: just reload all data
                loadAllData().finally(() => {
                     btn.disabled = false;
                     btn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Data';
                 });

                // More advanced: Call a backend endpoint to trigger python script
                /*
                fetch('/api/refresh-data', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            logFrontendEvent('Backend data fetch successful, reloading dashboard data...');
                            loadAllData(); // Reload data after backend script runs
                        } else {
                            logFrontendEvent('Backend data fetch failed: ' + (data.error || 'Unknown error'));
                            alert('Backend data fetch failed: ' + (data.error || 'Unknown error'));
                            updateLastDataFetch(false); // Indicate failure
                        }
                    })
                    .catch(err => {
                        logFrontendEvent('Error calling backend refresh: ' + err);
                        alert('Error triggering data refresh: ' + err);
                         updateLastDataFetch(false); // Indicate failure
                    })
                    .finally(() => {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Data';
                    });
                 */
            });

             // Chart metric toggle listener
             document.getElementById('dailyChartMetricToggle').addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    // Remove active class from all buttons in group
                    event.target.parentElement.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    // Add active class to the clicked button
                    event.target.classList.add('active');
                    // Update the chart
                    updateDailyUsageChart();
                }
            });


             // Tab change listener - re-render table for the activated tab
             document.querySelectorAll('#dataTabs button[data-bs-toggle="tab"]').forEach(button => {
                button.addEventListener('shown.bs.tab', function (event) {
                    logFrontendEvent(`Tab switched to: ${event.target.id}`);
                    tableState[event.target.id.split('-')[0]].currentPage = 1; // Reset page on tab switch
                    updateActiveTable(); // Render the newly shown table
                });
             });

             // Setup sorting listeners after initial data load populates headers
             // Delay slightly or call after table rendering? Let's call after loadAllData completes.
             // Moved setupTableSorting calls inside loadAllData's success path might be safer.
             // For now, call here assuming headers are static.
             setupTableSorting('userTable', 'user', userColumns);
             setupTableSorting('conversationTable', 'conversation', conversationColumns);
             setupTableSorting('sessionTable', 'session', sessionColumns);
             setupTableSorting('agentTable', 'agent', agentColumns);
             setupTableSorting('modelTable', 'model', modelColumns);

             // Periodically update the "last fetched" timestamp display
             setInterval(() => updateLastDataFetch(true), 60 * 1000); // Update every minute

        });

    </script>
</body>
</html>